# sat-sample のビルドについて

<div style="text-align:right;">
松永 裕介
2019.07.25 Ver.1
</div>

## はじめに
sat-sample は ymtools と同様に cmake を用いて Makefile の生成を行います．
そのため外部ライブラリが標準的な場所にインストールされている場合，
手順は非常に簡単です．

大まかな流れは以下のとおりです．

 1. [ビルドに必要なツールのインストール](#1-ビルドに必要なツールのインストール)
 2. [cmake の実行](#2-cmake-の実行)
 3. [mk_builddir.sh](#3-mk_builddirsh)
 4. [boot.sh](#4-bootsh)
 5. [make の実行](#5-make-の実行)
 6. [make test の実行](#6-make-test-の実行)
 7. [make install の実行](#7-make-install-の実行)

このうち 1. は PC 上のソフトウェア開発環境を一回インストールすれば以降
は必要ありません．たまにソフトウェアのバージョンアップが必要になるかも
しれません．
2. も通常は最初に一回だけ行えばよいですが，新たにソースファイルを追加
した時などにも実行する必要があります．
3. の mk_builddir.sh スクリプト と 4. の boot.sh スクリプト
は上記の手順を行うシェルスクリプトです．
特に複雑なことはしていませんが，毎回手でコマンドを打ち込むのは
面倒なのでこのようなスクリプトを用意しています．
5. はソースファイルに変更があった時には毎回実行します．
6. は自動テストです．
7. はコンパイルしたバイナリやライブラリ，ヘッダファイルをインストールします．


## 1. ビルドに必要なツールのインストール

sat-sample のビルドに必要なツールは以下のとおりです．

- cmake
- gcc/g++ もしくは clang/clang++
- python
- google-perftools

以下に個々のツールについて補足します．

- cmake
 現在，FreeBSD-12.0-RELEASE-p4 の cmake-3.14.4 を用いています．たぶん，
 cmake 3.2 以上なら大丈夫だと思います．

- gcc/g++ もしくは clang/clang++
 現在，FreeBSD-12.0-RELEASE の clang-6.0.1 を用いています．
 たぶん gcc-4.7 以降でも動くと思います．

- python
  python は大きく python-2.7 などの 2系列と python-3.6 などの 3系列があります．
  ここでは3系列を使います．

- google-perftools
  プロファイリングを行うためのライブラリです．旧来の gprof と異なり，google-perftools
  はコンパイル時にプロファイル用のコードを生成する必要がありません．
  実行時にリンクさえできればプロファイルしてくれます．
  ただ，リンク時にリンクしておいたほうが安全なのでこのパッケージが見つかったら
  リンクするようにしています．
  プロファイリングを ON にしない限り，オーバーヘッドはほとんどないと思います．
  FreeBSD の場合は ports/pkg に用意されています．


### 1.1 上記ツールがインストールされていない場合の対処

一番簡単なのは，計算機の管理者にいって，上記のツールの最新バージョンを
インストールしてもらうことですが，それが難しい場合には自分でソースをもっ
てきて，configure; make; make install する必要があります．
その場合，ymtools 用のディレクトリを用意してそこにこれら一連のツールを
インストールすることをおすすめします．YmTools の BUILDING.md も参考にしてください．


## 1.1.1 cmake のインストール

Linux 系で一番問題なのが多くのディストリビューションで用意されている cmake
が未だに 2.8 なことです．2015年8月8日時点で最新は 3.3 です．
cmake のダウンロードサイト(http://www.cmake.org/download/)からソース一式
(例えば cmake-3.3.0.tar.gz)を取ってきて，適当な場所に展開し，
```shell
$ ./bootstrap
$ gmake
$ sudo gmake install
```
を実行すれば(たぶん/usr/localの下に)cmake一式がインストールされます．
インストール先を変えたい場合は README.rst を見てください(--prefix オプションを使う)．
ただし，もともとのディストリビューションに古い cmake が含まれていた場合，
新しい cmake をインストールしてだけでは意味がありません．
古い cmake は削除してもかまわないのですが，パッケージの依存関係がいろいろと
あるのでそれもできません．実際に cmake を実行するときに新しい cmake
を呼ぶようにしてください．詳細は次に述べます．


## 2. cmake の実行

cmake の仕事は Cコンパイラなどのビルドツールの確認や必要なライブラリの
検索などを行って Makefile を生成することです．
ですのでソースファイルを追加したり，リンクするライブラリを追加したりす
るような Makefile に変更される場合には cmake を実行する必要があります．
逆に，ソースファイルの内容だけが変更された場合には Makefile の変更はあ
りませんので cmake を実行する必要はありません．

cmake はコンパイラやライブラリの場所や名前を巧妙な方法で探します．ライ
ブラリなどをデフォルトの位置にインストールしている場合にはほとんど何の
指定もせずに見つけてくれますが，自分のホームディレクトリの下にインストー
ルした場合などには cmake に位置を教える必要があります．
具体的な方法は cmake のマニュアルで調べてください．
通常，これらの指定は最初の一回だけ行えば，2回め以降は省略可能です．

[***重要***]
cmake はソースディレクトリ上で実行することも可能ですが，ソースディレク
トリはバージョン管理されたファイルが存在しますので，ビルド用の一時ファ
イルやコンパイル結果のファイルなどでソースディレクトリが汚れてしまうこ
とはあまり好ましいことではありません．たとえば git add ./* などとして
しまうと .gitignore で明示的に除外しておかない限りそのディレクトリにあ
るファイルがすべてバージョン管理の対象となってしまいます．
そこで，ビルド用に別のディレクトリを用意し，そこにコンパイル結果のファ
イルを置くことが一般的です．これは automake/autoconf でも同様です．
やりかたは極めて簡単です．今，ソースディレクトリを $(SRC_DIR) ビルドディ
レクトリを $(BUILD_DIR) とします．すると cmake の実行は以下のような手
順で行います．
```shell
$ mkdir -p $(BUILD_DIR)
$ cd $(BUILD_DIR)
$ cmake $(SRC_DIR)
```
これで $(BUILD_DIR) 以下に Makefile といくつかの作業用ディレクトリが生
成されます．

cmake に関してはまだ使いこなせていないのでいろいろ変わる可能性がありま
す．


## 3. mk_builddir.sh

上記の様に通常，ソースディレクトリとコンパイルディレクトリは別々に用意します．
これらの指示を cmake を実行するたびに手で打ち込むのは面倒だし，
間違いのもとなので，最初に cmake 起動用のスクリプトを作るスクリプトを用意しました．
今，コンパイルディレクトリを `compile_dir` とすると，ソースディレクトリ上で
```shell
$ ./mk_builddir compile_dir
```
と実行すると
~~~
****
source  directory: XXX
build   directory: XXX
****
continue ? (yes/no)
~~~
という表示が出ますので問題なければ yes と入力してください．
その後，`compile_dir`直下に do_cmake.sh というシェルスクリプト
が生成されます．


## 4. boot.sh

boot.sh は cmake を実行するだけのシェルスクリプトです．

上に書きましたが，古い cmake と新しい cmake が存在している場合，
ここで新しい cmake を起動しなければなりません．
そのためには `CMAKE` という環境変数に新しい cmake のパスを入れておけばOKです．
たとえば `/usr/local/bin/cmake` に cmake-3.3.0 がインストールされているとすると，
```shell
$ env CMAKE=/usr/local/bin/cmake ./do_cmake.sh
```
で新しい cmake を使ってくれます．
もしくは sh(bash) 系のシェルの場合は
```shell
$ export CMAKE=/usr/local/bin/cmake
```
を実行しておけば `env CMAKE=...` の部分は不要になります．
csh(tcsh) 系のシェルの場合は
```csh
% setenv CMAKE /usr/local/bin/cmake
```
です．

また，cmake 実行時(boot.sh実行時)に環境変数 `CC` および `CXX` をセットしておくと
Cコンパイラ/C++コンパイラを指定することができます．
例えば `/usr/local/bin/clagn34`, `/usr/local/bin/clang++34`をそれぞれCコンパイラ/C++コンパイラ
として使いたい場合(実はYmToolsではC++のみを使う)には，
```shell
$ env CC=/usr/local/bin/clang34 CXX=/usr/local/bin/clang++34 ./do_cmake.sh
```
を実行すればOKです．環境変数の設定は上と同様に `export` 文で一回設定してしまってもOKです．
`env` 文はその行のコマンド実行のみに環境変数が設定されます．

なお，`boot.sh` と同じディレクトリ(ビルドディレクトリ)に `boot-opt.sh`
というファイルがあるとこのファイルを読み込んで実行します．
ここに環境変数の設定を書いておけば，`boot.sh` を起動するたびに env コマンド
で環境変数の設定を行わなくてすみます．
また，`options` というシェル変数に値を設定しておくとこの変数の内容が
`cmake` を起動する時にオプションとして挿入されます．
`cmake` 用のマクロ定義`-DCMAKE_INSTALL_PREFIX=XXXX`のような指定に用いることができます．

通常は mk_builddir.sh でコンパイルディレクトリを用意した直後に一回だけ
このスクリプトを実行します．
ただし，ソースファイルを追加したり，リンクするライブラリを変更した場合には
再度 cmake を実行する必要が有ります．
普通は Makefile に cmake を再起動する make ルールが記述されているので
ただ単に make を打つだけで cmake が起動します．
特にスクリプトを使う必要もありませんが，ソースディレクトリやインストール
ディレクトリなど，一回決めてしまえば変わらないものなので毎回，
手で打ち込まずにこのスクリプトを実行するほうが簡単です．
逆に，このスクリプトはたいしたことはしていませんので
mk_builddir.sh で生成されたあとで中身を変更しても構いません．
ただし，上述のように `boot-opt.sh` を書き換えて `boot.sh` を不変にしておいたほうが
複数の環境でビルドする時に混乱しなくてすみます．

## 5. make の実行

cmake で問題が起こっていない限りあとは make とタイプするだけですべての
ビルドが完了します．

## 6. make test の実行

まだすごく不十分ですが，テストコードを作っています．
make が終わったら
~~~shell
make test
~~~
で各ライブラリのテストを行ってください．
現在は CTest (cmake のテストツール)と google-test ライブラリを用いて
います．このような枠組みは CppUnit とか CppUtest とかいろいろあって
いろいろ試しているのですが，現在は CTest と google-test になっています．
具体的には個々のライブラリのディレクトリ直下に gtest というディレクトリ
があってその下にテスト用のバイナリがあります．
それを直接実行すると詳細なテスト出力が読めます．

## 7. make install の実行

エラーがなければ最後に

~~~
$ make install
~~~

を実行すればインストールディレクトリにファイルがインストールされます．
特に設定を上書きしない限りインストールディレクトリは `${BUILDDIR}/stage`
となります．
